{"version":3,"file":"css-layout.min.js","sources":["css-layout.js"],"names":["root","factory","define","amd","exports","module","computeLayout","this","capitalizeFirst","str","charAt","toUpperCase","slice","getSpacing","node","type","suffix","locations","i","length","location","key","style","fillNodes","layout","width","undefined","height","top","left","right","bottom","children","measure","forEach","extractNodes","map","direction","getPositiveSpacing","isUndefined","value","isRowDirection","flexDirection","CSS_FLEX_DIRECTION_ROW","CSS_FLEX_DIRECTION_ROW_REVERSE","isColumnDirection","CSS_FLEX_DIRECTION_COLUMN","CSS_FLEX_DIRECTION_COLUMN_REVERSE","getLeadingLocations","axis","leading","unshift","getTrailingLocations","trailing","getMargin","getLeadingMargin","getTrailingMargin","getPadding","getLeadingPadding","getTrailingPadding","getBorder","getLeadingBorder","getTrailingBorder","getLeadingPaddingAndBorder","getTrailingPaddingAndBorder","getBorderAxis","getMarginAxis","getPaddingAndBorderAxis","getJustifyContent","justifyContent","getAlignContent","alignContent","getAlignItem","child","alignSelf","alignItems","resolveAxis","CSS_DIRECTION_RTL","resolveDirection","parentDirection","CSS_DIRECTION_INHERIT","CSS_DIRECTION_LTR","getFlexDirection","getCrossFlexDirection","getPositionType","position","getFlex","flex","isFlex","CSS_POSITION_RELATIVE","isFlexWrap","flexWrap","getDimWithMargin","dim","isDimDefined","isPosDefined","pos","isMeasureDefined","getPosition","boundAxis","min","row","minWidth","row-reverse","column","minHeight","column-reverse","max","maxWidth","maxHeight","boundValue","fmaxf","a","b","setDimensionFromStyle","setTrailingPosition","getRelativePosition","layoutNode","parentMaxWidth","mainAxis","crossAxis","resolvedRowAxis","CSS_UNDEFINED","isRowUndefined","isColumnUndefined","measureDim","ii","CSS_ALIGN_STRETCH","CSS_POSITION_ABSOLUTE","definedMainDim","startLine","endLine","alreadyComputedNextLayout","linesCrossDim","linesMainDim","linesCount","mainContentDim","flexibleChildrenCount","totalFlexible","nonFlexibleChildrenCount","nextContentDim","leadingMainDim","betweenMainDim","remainingMainDim","baseMainDim","boundMainDim","flexibleMainDim","CSS_JUSTIFY_CENTER","CSS_JUSTIFY_FLEX_END","CSS_JUSTIFY_SPACE_BETWEEN","CSS_JUSTIFY_SPACE_AROUND","crossDim","mainDim","lineIndex","containerCrossAxis","leadingCrossDim","alignItem","CSS_ALIGN_FLEX_START","remainingCrossDim","CSS_ALIGN_CENTER","nodeCrossAxisInnerSize","remainingAlignContentDim","crossDimLead","currentLead","CSS_ALIGN_FLEX_END","endIndex","startIndex","lineHeight","alignContentAlignItem","childHeight","needsMainTrailingPos","needsCrossTrailingPos"],"mappings":"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","sourcesContent":["// UMD (Universal Module Definition)\n// See https://github.com/umdjs/umd for reference\n//\n// This file uses the following specific UMD implementation:\n// https://github.com/umdjs/umd/blob/master/returnExports.js\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.computeLayout = factory();\n  }\n}(this, function () {\n    /**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar computeLayout = (function() {\n\n  var CSS_UNDEFINED;\n\n  var CSS_DIRECTION_INHERIT = 'inherit';\n  var CSS_DIRECTION_LTR = 'ltr';\n  var CSS_DIRECTION_RTL = 'rtl';\n\n  var CSS_FLEX_DIRECTION_ROW = 'row';\n  var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\n  var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';\n\n  // var CSS_JUSTIFY_FLEX_START = 'flex-start';\n  var CSS_JUSTIFY_CENTER = 'center';\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n  var CSS_ALIGN_FLEX_START = 'flex-start';\n  var CSS_ALIGN_CENTER = 'center';\n  var CSS_ALIGN_FLEX_END = 'flex-end';\n  var CSS_ALIGN_STRETCH = 'stretch';\n\n  var CSS_POSITION_RELATIVE = 'relative';\n  var CSS_POSITION_ABSOLUTE = 'absolute';\n\n  var leading = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var trailing = {\n    'row': 'right',\n    'row-reverse': 'left',\n    'column': 'bottom',\n    'column-reverse': 'top'\n  };\n  var pos = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var dim = {\n    'row': 'width',\n    'row-reverse': 'width',\n    'column': 'height',\n    'column-reverse': 'height'\n  };\n\n  function capitalizeFirst(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }\n\n  function getSpacing(node, type, suffix, locations) {\n    for (var i = 0; i < locations.length; ++i) {\n      var location = locations[i];\n\n      var key = type + capitalizeFirst(location) + suffix;\n      if (key in node.style) {\n        return node.style[key];\n      }\n\n      key = type + suffix;\n      if (key in node.style) {\n        return node.style[key];\n      }\n    }\n\n    return 0;\n  }\n  function fillNodes(node) {\n    node.layout = {\n      width: undefined,\n      height: undefined,\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    };\n    if (!node.style) {\n      node.style = {};\n    }\n\n    if (!node.children || node.style.measure) {\n      node.children = [];\n    }\n    node.children.forEach(fillNodes);\n    return node;\n  }\n\n  function extractNodes(node) {\n    var layout = node.layout;\n    delete node.layout;\n    if (node.children && node.children.length > 0) {\n      layout.children = node.children.map(extractNodes);\n    } else {\n      delete node.children;\n    }\n\n    delete layout.right;\n    delete layout.bottom;\n    delete layout.direction;\n\n    return layout;\n  }\n\n  function getPositiveSpacing(node, type, suffix, locations) {\n    for (var i = 0; i < locations.length; ++i) {\n      var location = locations[i];\n\n      var key = type + capitalizeFirst(location) + suffix;\n      if (key in node.style && node.style[key] >= 0) {\n        return node.style[key];\n      }\n\n      key = type + suffix;\n      if (key in node.style && node.style[key] >= 0) {\n        return node.style[key];\n      }\n    }\n\n    return 0;\n  }\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n\n  function isRowDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_ROW ||\n           flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;\n  }\n\n  function isColumnDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_COLUMN ||\n           flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;\n  }\n\n  function getLeadingLocations(axis) {\n    var locations = [leading[axis]];\n    if (isRowDirection(axis)) {\n      locations.unshift('start');\n    }\n\n    return locations;\n  }\n\n  function getTrailingLocations(axis) {\n    var locations = [trailing[axis]];\n    if (isRowDirection(axis)) {\n      locations.unshift('end');\n    }\n\n    return locations;\n  }\n\n  function getMargin(node, locations) {\n    return getSpacing(node, 'margin', '', locations);\n  }\n\n  function getLeadingMargin(node, axis) {\n    return getMargin(node, getLeadingLocations(axis));\n  }\n\n  function getTrailingMargin(node, axis) {\n    return getMargin(node, getTrailingLocations(axis));\n  }\n\n  function getPadding(node, locations) {\n    return getPositiveSpacing(node, 'padding', '', locations);\n  }\n\n  function getLeadingPadding(node, axis) {\n    return getPadding(node, getLeadingLocations(axis));\n  }\n\n  function getTrailingPadding(node, axis) {\n    return getPadding(node, getTrailingLocations(axis));\n  }\n\n  function getBorder(node, locations) {\n    return getPositiveSpacing(node, 'border', 'Width', locations);\n  }\n\n  function getLeadingBorder(node, axis) {\n    return getBorder(node, getLeadingLocations(axis));\n  }\n\n  function getTrailingBorder(node, axis) {\n    return getBorder(node, getTrailingLocations(axis));\n  }\n\n  function getLeadingPaddingAndBorder(node, axis) {\n    return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);\n  }\n\n  function getTrailingPaddingAndBorder(node, axis) {\n    return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getBorderAxis(node, axis) {\n    return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getMarginAxis(node, axis) {\n    return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);\n  }\n\n  function getPaddingAndBorderAxis(node, axis) {\n    return getLeadingPaddingAndBorder(node, axis) +\n        getTrailingPaddingAndBorder(node, axis);\n  }\n\n  function getJustifyContent(node) {\n    if ('justifyContent' in node.style) {\n      return node.style.justifyContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignContent(node) {\n    if ('alignContent' in node.style) {\n      return node.style.alignContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignItem(node, child) {\n    if ('alignSelf' in child.style) {\n      return child.style.alignSelf;\n    }\n    if ('alignItems' in node.style) {\n      return node.style.alignItems;\n    }\n    return 'stretch';\n  }\n\n  function resolveAxis(axis, direction) {\n    if (direction === CSS_DIRECTION_RTL) {\n      if (axis === CSS_FLEX_DIRECTION_ROW) {\n        return CSS_FLEX_DIRECTION_ROW_REVERSE;\n      } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {\n        return CSS_FLEX_DIRECTION_ROW;\n      }\n    }\n\n    return axis;\n  }\n\n  function resolveDirection(node, parentDirection) {\n    var direction;\n    if ('direction' in node.style) {\n      direction = node.style.direction;\n    } else {\n      direction = CSS_DIRECTION_INHERIT;\n    }\n\n    if (direction === CSS_DIRECTION_INHERIT) {\n      direction = (parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection);\n    }\n\n    return direction;\n  }\n\n  function getFlexDirection(node) {\n    if ('flexDirection' in node.style) {\n      return node.style.flexDirection;\n    }\n    return CSS_FLEX_DIRECTION_COLUMN;\n  }\n\n  function getCrossFlexDirection(flexDirection, direction) {\n    if (isColumnDirection(flexDirection)) {\n      return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n    } else {\n      return CSS_FLEX_DIRECTION_COLUMN;\n    }\n  }\n\n  function getPositionType(node) {\n    if ('position' in node.style) {\n      return node.style.position;\n    }\n    return 'relative';\n  }\n\n  function getFlex(node) {\n    return node.style.flex;\n  }\n\n  function isFlex(node) {\n    return (\n      getPositionType(node) === CSS_POSITION_RELATIVE &&\n      getFlex(node) > 0\n    );\n  }\n\n  function isFlexWrap(node) {\n    return node.style.flexWrap === 'wrap';\n  }\n\n  function getDimWithMargin(node, axis) {\n    return node.layout[dim[axis]] + getMarginAxis(node, axis);\n  }\n\n  function isDimDefined(node, axis) {\n    return !isUndefined(node.style[dim[axis]]) && node.style[dim[axis]] >= 0;\n  }\n\n  function isPosDefined(node, pos) {\n    return !isUndefined(node.style[pos]);\n  }\n\n  function isMeasureDefined(node) {\n    return 'measure' in node.style;\n  }\n\n  function getPosition(node, pos) {\n    if (pos in node.style) {\n      return node.style[pos];\n    }\n    return 0;\n  }\n\n  function boundAxis(node, axis, value) {\n    var min = {\n      'row': node.style.minWidth,\n      'row-reverse': node.style.minWidth,\n      'column': node.style.minHeight,\n      'column-reverse': node.style.minHeight\n    }[axis];\n\n    var max = {\n      'row': node.style.maxWidth,\n      'row-reverse': node.style.maxWidth,\n      'column': node.style.maxHeight,\n      'column-reverse': node.style.maxHeight\n    }[axis];\n\n    var boundValue = value;\n    if (!isUndefined(max) && max >= 0 && boundValue > max) {\n      boundValue = max;\n    }\n    if (!isUndefined(min) && min >= 0 && boundValue < min) {\n      boundValue = min;\n    }\n    return boundValue;\n  }\n\n  function fmaxf(a, b) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  // When the user specifically sets a value for width or height\n  function setDimensionFromStyle(node, axis) {\n    // The parent already computed us a width or height. We just skip it\n    if (!isUndefined(node.layout[dim[axis]])) {\n      return;\n    }\n    // We only run if there's a width or height defined\n    if (!isDimDefined(node, axis)) {\n      return;\n    }\n\n    // The dimensions can never be smaller than the padding and border\n    node.layout[dim[axis]] = fmaxf(\n      boundAxis(node, axis, node.style[dim[axis]]),\n      getPaddingAndBorderAxis(node, axis)\n    );\n  }\n\n  function setTrailingPosition(node, child, axis) {\n    child.layout[trailing[axis]] = node.layout[dim[axis]] -\n        child.layout[dim[axis]] - child.layout[pos[axis]];\n  }\n\n  // If both left and right are defined, then use left. Otherwise return\n  // +left or -right depending on which is defined.\n  function getRelativePosition(node, axis) {\n    if (leading[axis] in node.style) {\n      return getPosition(node, leading[axis]);\n    }\n    return -getPosition(node, trailing[axis]);\n  }\n\n  function layoutNode(node, parentMaxWidth, /*css_direction_t*/parentDirection) {\n    var/*css_direction_t*/ direction = resolveDirection(node, parentDirection);\n    var/*css_flex_direction_t*/ mainAxis = resolveAxis(getFlexDirection(node), direction);\n    var/*css_flex_direction_t*/ crossAxis = getCrossFlexDirection(mainAxis, direction);\n    var/*css_flex_direction_t*/ resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n\n    // Handle width and height style attributes\n    setDimensionFromStyle(node, mainAxis);\n    setDimensionFromStyle(node, crossAxis);\n\n    // Set the resolved resolution in the node's layout\n    node.layout.direction = direction;\n\n    // The position is set by the parent, but we need to complete it with a\n    // delta composed of the margin and left/top/right/bottom\n    node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n    node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n\n    if (isMeasureDefined(node)) {\n      var/*float*/ width = CSS_UNDEFINED;\n      if (isDimDefined(node, resolvedRowAxis)) {\n        width = node.style.width;\n      } else if (!isUndefined(node.layout[dim[resolvedRowAxis]])) {\n        width = node.layout[dim[resolvedRowAxis]];\n      } else {\n        width = parentMaxWidth -\n          getMarginAxis(node, resolvedRowAxis);\n      }\n      width -= getPaddingAndBorderAxis(node, resolvedRowAxis);\n\n      // We only need to give a dimension for the text if we haven't got any\n      // for it computed yet. It can either be from the style attribute or because\n      // the element is flexible.\n      var/*bool*/ isRowUndefined = !isDimDefined(node, resolvedRowAxis) &&\n        isUndefined(node.layout[dim[resolvedRowAxis]]);\n      var/*bool*/ isColumnUndefined = !isDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\n\n      // Let's not measure the text if we already know both dimensions\n      if (isRowUndefined || isColumnUndefined) {\n        var/*css_dim_t*/ measureDim = node.style.measure(\n          /*(c)!node->context,*/\n          /*(java)!layoutContext.measureOutput,*/\n          width\n        );\n        if (isRowUndefined) {\n          node.layout.width = measureDim.width +\n            getPaddingAndBorderAxis(node, resolvedRowAxis);\n        }\n        if (isColumnUndefined) {\n          node.layout.height = measureDim.height +\n            getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n        }\n      }\n      if (node.children.length === 0) {\n        return;\n      }\n    }\n\n    var/*int*/ i;\n    var/*int*/ ii;\n    var/*css_node_t**/ child;\n    var/*css_flex_direction_t*/ axis;\n\n    // Pre-fill some dimensions straight from the parent\n    for (i = 0; i < node.children.length; ++i) {\n      child = node.children[i];\n      // Pre-fill cross axis dimensions when the child is using stretch before\n      // we call the recursive layout pass\n      if (getAlignItem(node, child) === CSS_ALIGN_STRETCH &&\n          getPositionType(child) === CSS_POSITION_RELATIVE &&\n          !isUndefined(node.layout[dim[crossAxis]]) &&\n          !isDimDefined(child, crossAxis)) {\n        child.layout[dim[crossAxis]] = fmaxf(\n          boundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\n            getPaddingAndBorderAxis(node, crossAxis) -\n            getMarginAxis(child, crossAxis)),\n          // You never want to go smaller than padding\n          getPaddingAndBorderAxis(child, crossAxis)\n        );\n      } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n        // left and right or top and bottom).\n        for (ii = 0; ii < 2; ii++) {\n          axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (!isUndefined(node.layout[dim[axis]]) &&\n              !isDimDefined(child, axis) &&\n              isPosDefined(child, leading[axis]) &&\n              isPosDefined(child, trailing[axis])) {\n            child.layout[dim[axis]] = fmaxf(\n              boundAxis(child, axis, node.layout[dim[axis]] -\n                getPaddingAndBorderAxis(node, axis) -\n                getMarginAxis(child, axis) -\n                getPosition(child, leading[axis]) -\n                getPosition(child, trailing[axis])),\n              // You never want to go smaller than padding\n              getPaddingAndBorderAxis(child, axis)\n            );\n          }\n        }\n      }\n    }\n\n    var/*float*/ definedMainDim = CSS_UNDEFINED;\n    if (!isUndefined(node.layout[dim[mainAxis]])) {\n      definedMainDim = node.layout[dim[mainAxis]] -\n          getPaddingAndBorderAxis(node, mainAxis);\n    }\n\n    // We want to execute the next two loops one per line with flex-wrap\n    var/*int*/ startLine = 0;\n    var/*int*/ endLine = 0;\n    // var/*int*/ nextOffset = 0;\n    var/*int*/ alreadyComputedNextLayout = 0;\n    // We aggregate the total dimensions of the container in those two variables\n    var/*float*/ linesCrossDim = 0;\n    var/*float*/ linesMainDim = 0;\n    var/*int*/ linesCount = 0;\n    while (endLine < node.children.length) {\n      // <Loop A> Layout non flexible children and count children by type\n\n      // mainContentDim is accumulation of the dimensions and margin of all the\n      // non flexible children. This will be used in order to either set the\n      // dimensions of the node if none already exist, or to compute the\n      // remaining space left for the flexible children.\n      var/*float*/ mainContentDim = 0;\n\n      // There are three kind of children, non flexible, flexible and absolute.\n      // We need to know how many there are in order to distribute the space.\n      var/*int*/ flexibleChildrenCount = 0;\n      var/*float*/ totalFlexible = 0;\n      var/*int*/ nonFlexibleChildrenCount = 0;\n\n      var/*float*/ maxWidth;\n      for (i = startLine; i < node.children.length; ++i) {\n        child = node.children[i];\n        var/*float*/ nextContentDim = 0;\n\n        // It only makes sense to consider a child flexible if we have a computed\n        // dimension for the node.\n        if (!isUndefined(node.layout[dim[mainAxis]]) && isFlex(child)) {\n          flexibleChildrenCount++;\n          totalFlexible += getFlex(child);\n\n          // Even if we don't know its exact size yet, we already know the padding,\n          // border and margin. We'll use this partial information, which represents\n          // the smallest possible size for the child, to compute the remaining\n          // available space.\n          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\n            getMarginAxis(child, mainAxis);\n\n        } else {\n          maxWidth = CSS_UNDEFINED;\n          if (!isRowDirection(mainAxis)) {\n            maxWidth = parentMaxWidth -\n              getMarginAxis(node, resolvedRowAxis) -\n              getPaddingAndBorderAxis(node, resolvedRowAxis);\n\n            if (isDimDefined(node, resolvedRowAxis)) {\n              maxWidth = node.layout[dim[resolvedRowAxis]] -\n                getPaddingAndBorderAxis(node, resolvedRowAxis);\n            }\n          }\n\n          // This is the main recursive call. We layout non flexible children.\n          if (alreadyComputedNextLayout === 0) {\n            layoutNode(/*(java)!layoutContext, */child, maxWidth, direction);\n          }\n\n          // Absolute positioned elements do not take part of the layout, so we\n          // don't use them to compute mainContentDim\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            nonFlexibleChildrenCount++;\n            // At this point we know the final size and margin of the element.\n            nextContentDim = getDimWithMargin(child, mainAxis);\n          }\n        }\n\n        // The element we are about to add would make us go to the next line\n        if (isFlexWrap(node) &&\n            !isUndefined(node.layout[dim[mainAxis]]) &&\n            mainContentDim + nextContentDim > definedMainDim &&\n            // If there's only one element, then it's bigger than the content\n            // and needs its own line\n            i !== startLine) {\n          nonFlexibleChildrenCount--;\n          alreadyComputedNextLayout = 1;\n          break;\n        }\n        alreadyComputedNextLayout = 0;\n        mainContentDim += nextContentDim;\n        endLine = i + 1;\n      }\n\n      // <Loop B> Layout flexible children and allocate empty space\n\n      // In order to position the elements in the main axis, we have two\n      // controls. The space between the beginning and the first element\n      // and the space between each two elements.\n      var/*float*/ leadingMainDim = 0;\n      var/*float*/ betweenMainDim = 0;\n\n      // The remaining available space that needs to be allocated\n      var/*float*/ remainingMainDim = 0;\n      if (!isUndefined(node.layout[dim[mainAxis]])) {\n        remainingMainDim = definedMainDim - mainContentDim;\n      } else {\n        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n      }\n\n      // If there are flexible children in the mix, they are going to fill the\n      // remaining space\n      if (flexibleChildrenCount !== 0) {\n        var/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\n        var/*float*/ baseMainDim;\n        var/*float*/ boundMainDim;\n\n        // Iterate over every child in the axis. If the flex share of remaining\n        // space doesn't meet min/max bounds, remove this child from flex\n        // calculations.\n        for (i = startLine; i < endLine; ++i) {\n          child = node.children[i];\n          if (isFlex(child)) {\n            baseMainDim = flexibleMainDim * getFlex(child) +\n                getPaddingAndBorderAxis(child, mainAxis);\n            boundMainDim = boundAxis(child, mainAxis, baseMainDim);\n\n            if (baseMainDim !== boundMainDim) {\n              remainingMainDim -= boundMainDim;\n              totalFlexible -= getFlex(child);\n            }\n          }\n        }\n        flexibleMainDim = remainingMainDim / totalFlexible;\n\n        // The non flexible children can overflow the container, in this case\n        // we should just assume that there is no space available.\n        if (flexibleMainDim < 0) {\n          flexibleMainDim = 0;\n        }\n        // We iterate over the full array and only apply the action on flexible\n        // children. This is faster than actually allocating a new array that\n        // contains only flexible children.\n        for (i = startLine; i < endLine; ++i) {\n          child = node.children[i];\n          if (isFlex(child)) {\n            // At this point we know the final size of the element in the main\n            // dimension\n            child.layout[dim[mainAxis]] = boundAxis(child, mainAxis,\n              flexibleMainDim * getFlex(child) + getPaddingAndBorderAxis(child, mainAxis)\n            );\n\n            maxWidth = CSS_UNDEFINED;\n            if (isDimDefined(node, resolvedRowAxis)) {\n              maxWidth = node.layout[dim[resolvedRowAxis]] -\n                getPaddingAndBorderAxis(node, resolvedRowAxis);\n            } else if (!isRowDirection(mainAxis)) {\n              maxWidth = parentMaxWidth -\n                getMarginAxis(node, resolvedRowAxis) -\n                getPaddingAndBorderAxis(node, resolvedRowAxis);\n            }\n\n            // And we recursively call the layout algorithm for this child\n            layoutNode(/*(java)!layoutContext, */child, maxWidth, direction);\n          }\n        }\n\n      // We use justifyContent to figure out how to allocate the remaining\n      // space available\n      } else {\n        var/*css_justify_t*/ justifyContent = getJustifyContent(node);\n        if (justifyContent === CSS_JUSTIFY_CENTER) {\n          leadingMainDim = remainingMainDim / 2;\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n          leadingMainDim = remainingMainDim;\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n          remainingMainDim = fmaxf(remainingMainDim, 0);\n          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n            betweenMainDim = remainingMainDim /\n              (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n          } else {\n            betweenMainDim = 0;\n          }\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n          // Space on the edges is half of the space between elements\n          betweenMainDim = remainingMainDim /\n            (flexibleChildrenCount + nonFlexibleChildrenCount);\n          leadingMainDim = betweenMainDim / 2;\n        }\n      }\n\n      // <Loop C> Position elements in the main axis and compute dimensions\n\n      // At this point, all the children have their dimensions set. We need to\n      // find their position. In order to do that, we accumulate data in\n      // variables that are also useful to compute the total dimensions of the\n      // container!\n      var/*float*/ crossDim = 0;\n      var/*float*/ mainDim = leadingMainDim +\n        getLeadingPaddingAndBorder(node, mainAxis);\n\n      for (i = startLine; i < endLine; ++i) {\n        child = node.children[i];\n        child.lineIndex = linesCount;\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[mainAxis])) {\n          // In case the child is position absolute and has left/top being\n          // defined, we override the position to whatever the user said\n          // (and margin/border).\n          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\n            getLeadingBorder(node, mainAxis) +\n            getLeadingMargin(child, mainAxis);\n        } else {\n          // If the child is position absolute (without top/left) or relative,\n          // we put it at the current accumulated offset.\n          child.layout[pos[mainAxis]] += mainDim;\n\n          // Define the trailing position accordingly.\n          if (!isUndefined(node.layout[dim[mainAxis]])) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n        }\n\n        // Now that we placed the element, we need to update the variables\n        // We only need to do that for relative elements. Absolute elements\n        // do not take part in that phase.\n        if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n          // The main dimension is the sum of all the elements dimension plus\n          // the spacing.\n          mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n          // The cross dimension is the max of the elements dimension since there\n          // can only be one element in that cross dimension.\n          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n        }\n      }\n\n      var/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\n      if (isUndefined(node.layout[dim[crossAxis]])) {\n        containerCrossAxis = fmaxf(\n          // For the cross dim, we add both sides at the end because the value\n          // is aggregate via a max function. Intermediate negative values\n          // can mess this computation otherwise\n          boundAxis(node, crossAxis, crossDim + getPaddingAndBorderAxis(node, crossAxis)),\n          getPaddingAndBorderAxis(node, crossAxis)\n        );\n      }\n\n      // <Loop D> Position elements in the cross axis\n      for (i = startLine; i < endLine; ++i) {\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[crossAxis])) {\n          // In case the child is absolutely positionned and has a\n          // top/left/bottom/right being set, we override all the previously\n          // computed positions to set it correctly.\n          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\n            getLeadingBorder(node, crossAxis) +\n            getLeadingMargin(child, crossAxis);\n\n        } else {\n          var/*float*/ leadingCrossDim = getLeadingPaddingAndBorder(node, crossAxis);\n\n          // For a relative children, we're either using alignItems (parent) or\n          // alignSelf (child) in order to determine the position in the cross axis\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            var/*css_align_t*/ alignItem = getAlignItem(node, child);\n            if (alignItem === CSS_ALIGN_STRETCH) {\n              // You can only stretch if the dimension has not already been set\n              // previously.\n              if (!isDimDefined(child, crossAxis)) {\n                child.layout[dim[crossAxis]] = fmaxf(\n                  boundAxis(child, crossAxis, containerCrossAxis -\n                    getPaddingAndBorderAxis(node, crossAxis) -\n                    getMarginAxis(child, crossAxis)),\n                  // You never want to go smaller than padding\n                  getPaddingAndBorderAxis(child, crossAxis)\n                );\n              }\n            } else if (alignItem !== CSS_ALIGN_FLEX_START) {\n              // The remaining space between the parent dimensions+padding and child\n              // dimensions+margin.\n              var/*float*/ remainingCrossDim = containerCrossAxis -\n                getPaddingAndBorderAxis(node, crossAxis) -\n                getDimWithMargin(child, crossAxis);\n\n              if (alignItem === CSS_ALIGN_CENTER) {\n                leadingCrossDim += remainingCrossDim / 2;\n              } else { // CSS_ALIGN_FLEX_END\n                leadingCrossDim += remainingCrossDim;\n              }\n            }\n          }\n\n          // And we apply the position\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n\n          // Define the trailing position accordingly.\n          if (!isUndefined(node.layout[dim[crossAxis]])) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n      }\n\n      linesCrossDim += crossDim;\n      linesMainDim = fmaxf(linesMainDim, mainDim);\n      linesCount += 1;\n      startLine = endLine;\n    }\n\n    // <Loop E>\n    //\n    // Note(prenaux): More than one line, we need to layout the crossAxis\n    // according to alignContent.\n    //\n    // Note that we could probably remove <Loop D> and handle the one line case\n    // here too, but for the moment this is safer since it won't interfere with\n    // previously working code.\n    //\n    // See specs:\n    // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm\n    // section 9.4\n    //\n    if (linesCount > 1 &&\n        !isUndefined(node.layout[dim[crossAxis]])) {\n      var/*float*/ nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] -\n          getPaddingAndBorderAxis(node, crossAxis);\n      var/*float*/ remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;\n\n      var/*float*/ crossDimLead = 0;\n      var/*float*/ currentLead = getLeadingPaddingAndBorder(node, crossAxis);\n\n      var/*css_align_t*/ alignContent = getAlignContent(node);\n      if (alignContent === CSS_ALIGN_FLEX_END) {\n        currentLead += remainingAlignContentDim;\n      } else if (alignContent === CSS_ALIGN_CENTER) {\n        currentLead += remainingAlignContentDim / 2;\n      } else if (alignContent === CSS_ALIGN_STRETCH) {\n        if (nodeCrossAxisInnerSize > linesCrossDim) {\n          crossDimLead = (remainingAlignContentDim / linesCount);\n        }\n      }\n\n      var/*int*/ endIndex = 0;\n      for (i = 0; i < linesCount; ++i) {\n        var/*int*/ startIndex = endIndex;\n\n        // compute the line's height and find the endIndex\n        var/*float*/ lineHeight = 0;\n        for (ii = startIndex; ii < node.children.length; ++ii) {\n          child = node.children[ii];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n          if (child.lineIndex !== i) {\n            break;\n          }\n          if (!isUndefined(child.layout[dim[crossAxis]])) {\n            lineHeight = fmaxf(\n              lineHeight,\n              child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n            );\n          }\n        }\n        endIndex = ii;\n        lineHeight += crossDimLead;\n\n        for (ii = startIndex; ii < endIndex; ++ii) {\n          child = node.children[ii];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n\n          var/*css_align_t*/ alignContentAlignItem = getAlignItem(node, child);\n          if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n          } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {\n            child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];\n          } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {\n            var/*float*/ childHeight = child.layout[dim[crossAxis]];\n            child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n          } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n            // TODO(prenaux): Correctly set the height of items with undefined\n            //                (auto) crossAxis dimension.\n          }\n        }\n\n        currentLead += lineHeight;\n      }\n    }\n\n    var/*bool*/ needsMainTrailingPos = false;\n    var/*bool*/ needsCrossTrailingPos = false;\n\n    // If the user didn't specify a width or height, and it has not been set\n    // by the container, then we set it via the children.\n    if (isUndefined(node.layout[dim[mainAxis]])) {\n      node.layout[dim[mainAxis]] = fmaxf(\n        // We're missing the last padding at this point to get the final\n        // dimension\n        boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n        // We can never assign a width smaller than the padding and borders\n        getPaddingAndBorderAxis(node, mainAxis)\n      );\n\n      needsMainTrailingPos = true;\n    }\n\n    if (isUndefined(node.layout[dim[crossAxis]])) {\n      node.layout[dim[crossAxis]] = fmaxf(\n        // For the cross dim, we add both sides at the end because the value\n        // is aggregate via a max function. Intermediate negative values\n        // can mess this computation otherwise\n        boundAxis(node, crossAxis, linesCrossDim + getPaddingAndBorderAxis(node, crossAxis)),\n        getPaddingAndBorderAxis(node, crossAxis)\n      );\n\n      needsCrossTrailingPos = true;\n    }\n\n    // <Loop F> Set trailing position if necessary\n    if (needsMainTrailingPos || needsCrossTrailingPos) {\n      for (i = 0; i < node.children.length; ++i) {\n        child = node.children[i];\n\n        if (needsMainTrailingPos) {\n          setTrailingPosition(node, child, mainAxis);\n        }\n\n        if (needsCrossTrailingPos) {\n          setTrailingPosition(node, child, crossAxis);\n        }\n      }\n    }\n\n    // <Loop G> Calculate dimensions for absolutely positioned elements\n    for (i = 0; i < node.children.length; ++i) {\n      child = node.children[i];\n      if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n        // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n        // left and right or top and bottom).\n        for (ii = 0; ii < 2; ii++) {\n          axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (!isUndefined(node.layout[dim[axis]]) &&\n              !isDimDefined(child, axis) &&\n              isPosDefined(child, leading[axis]) &&\n              isPosDefined(child, trailing[axis])) {\n            child.layout[dim[axis]] = fmaxf(\n              boundAxis(child, axis, node.layout[dim[axis]] -\n                getBorderAxis(node, axis) -\n                getMarginAxis(child, axis) -\n                getPosition(child, leading[axis]) -\n                getPosition(child, trailing[axis])\n              ),\n              // You never want to go smaller than padding\n              getPaddingAndBorderAxis(child, axis)\n            );\n          }\n        }\n        for (ii = 0; ii < 2; ii++) {\n          axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n          if (isPosDefined(child, trailing[axis]) &&\n              !isPosDefined(child, leading[axis])) {\n            child.layout[leading[axis]] =\n              node.layout[dim[axis]] -\n              child.layout[dim[axis]] -\n              getPosition(child, trailing[axis]);\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    computeLayout: layoutNode,\n    fillNodes: fillNodes,\n    extractNodes: extractNodes\n  };\n})();\n\nif (typeof exports === 'object') {\n  module.exports = computeLayout;\n}\n\n    return function(node) {\n      node = computeLayout.fillNodes(node);\n      computeLayout.computeLayout(node);\n      node = computeLayout.extractNodes(node);\n      return node;\n  };\n}));\n"]}