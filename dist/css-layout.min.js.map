{"version":3,"sources":["css-layout.js"],"names":["root","factory","define","amd","exports","module","computeLayout","this","fillNodes","node","layout","isDirty","width","undefined","height","top","left","right","bottom","style","children","measure","length","Error","forEach","isUndefined","value","isNaN","isRowDirection","flexDirection","CSS_FLEX_DIRECTION_ROW","CSS_FLEX_DIRECTION_ROW_REVERSE","isColumnDirection","CSS_FLEX_DIRECTION_COLUMN","CSS_FLEX_DIRECTION_COLUMN_REVERSE","getLeadingMargin","axis","marginStart","marginLeft","marginRight","marginTop","marginBottom","margin","getTrailingMargin","marginEnd","getLeadingPadding","paddingStart","paddingLeft","paddingRight","paddingTop","paddingBottom","padding","getTrailingPadding","paddingEnd","getLeadingBorder","borderStartWidth","borderLeftWidth","borderRightWidth","borderTopWidth","borderBottomWidth","borderWidth","getTrailingBorder","borderEndWidth","getLeadingPaddingAndBorder","getTrailingPaddingAndBorder","getBorderAxis","getMarginAxis","getPaddingAndBorderAxis","getJustifyContent","justifyContent","getAlignContent","alignContent","getAlignItem","child","alignSelf","alignItems","resolveAxis","direction","CSS_DIRECTION_RTL","resolveDirection","parentDirection","CSS_DIRECTION_INHERIT","CSS_DIRECTION_LTR","getFlexDirection","getCrossFlexDirection","getPositionType","position","isFlex","CSS_POSITION_RELATIVE","flex","isFlexWrap","flexWrap","getDimWithMargin","dim","isStyleDimDefined","isLayoutDimDefined","isPosDefined","pos","isMeasureDefined","getPosition","boundAxis","min","row","minWidth","row-reverse","column","minHeight","column-reverse","max","maxWidth","maxHeight","boundValue","fmaxf","a","b","setDimensionFromStyle","setTrailingPosition","trailing","getRelativePosition","leading","layoutNodeImpl","parentMaxWidth","parentMaxHeight","mainAxis","crossAxis","resolvedRowAxis","childCount","paddingAndBorderAxisResolvedRow","paddingAndBorderAxisColumn","isResolvedRowDimDefined","CSS_UNDEFINED","widthMode","CSS_MEASURE_MODE_UNDEFINED","CSS_MEASURE_MODE_EXACTLY","CSS_MEASURE_MODE_AT_MOST","heightMode","isRowUndefined","isColumnUndefined","measureDim","i","ii","isNodeFlexWrap","leadingPaddingAndBorderMain","leadingPaddingAndBorderCross","paddingAndBorderAxisMain","paddingAndBorderAxisCross","isMainDimDefined","isCrossDimDefined","isMainRowDirection","firstAbsoluteChild","currentAbsoluteChild","definedMainDim","startLine","endLine","alreadyComputedNextLayout","linesCrossDim","linesMainDim","linesCount","mainContentDim","flexibleChildrenCount","totalFlexible","nonFlexibleChildrenCount","isSimpleStackMain","CSS_JUSTIFY_FLEX_START","CSS_JUSTIFY_CENTER","firstComplexMain","isSimpleStackCross","firstComplexCross","firstFlexChild","currentFlexChild","mainDim","crossDim","lineIndex","nextAbsoluteChild","nextFlexChild","alignItem","CSS_ALIGN_STRETCH","CSS_POSITION_ABSOLUTE","nextContentDim","layoutNode","CSS_ALIGN_FLEX_START","leadingMainDim","betweenMainDim","remainingMainDim","baseMainDim","boundMainDim","flexibleMainDim","CSS_JUSTIFY_FLEX_END","CSS_JUSTIFY_SPACE_BETWEEN","CSS_JUSTIFY_SPACE_AROUND","containerCrossAxis","leadingCrossDim","dimCrossAxis","remainingCrossDim","CSS_ALIGN_CENTER","nodeCrossAxisInnerSize","remainingAlignContentDim","crossDimLead","currentLead","CSS_ALIGN_FLEX_END","endIndex","startIndex","lineHeight","alignContentAlignItem","childHeight","needsMainTrailingPos","needsCrossTrailingPos","shouldUpdate","skipLayout","lastLayout","requestedHeight","requestedWidth"],"mappings":"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","file":"css-layout.min.js","sourcesContent":["// UMD (Universal Module Definition)\n// See https://github.com/umdjs/umd for reference\n//\n// This file uses the following specific UMD implementation:\n// https://github.com/umdjs/umd/blob/master/templates/returnExports.js\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.computeLayout = factory();\n  }\n}(this, function() {\n  /**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\nvar computeLayout = (function() {\n\n  var CSS_UNDEFINED;\n\n  var CSS_DIRECTION_INHERIT = 'inherit';\n  var CSS_DIRECTION_LTR = 'ltr';\n  var CSS_DIRECTION_RTL = 'rtl';\n\n  var CSS_FLEX_DIRECTION_ROW = 'row';\n  var CSS_FLEX_DIRECTION_ROW_REVERSE = 'row-reverse';\n  var CSS_FLEX_DIRECTION_COLUMN = 'column';\n  var CSS_FLEX_DIRECTION_COLUMN_REVERSE = 'column-reverse';\n\n  var CSS_JUSTIFY_FLEX_START = 'flex-start';\n  var CSS_JUSTIFY_CENTER = 'center';\n  var CSS_JUSTIFY_FLEX_END = 'flex-end';\n  var CSS_JUSTIFY_SPACE_BETWEEN = 'space-between';\n  var CSS_JUSTIFY_SPACE_AROUND = 'space-around';\n\n  var CSS_ALIGN_FLEX_START = 'flex-start';\n  var CSS_ALIGN_CENTER = 'center';\n  var CSS_ALIGN_FLEX_END = 'flex-end';\n  var CSS_ALIGN_STRETCH = 'stretch';\n\n  var CSS_POSITION_RELATIVE = 'relative';\n  var CSS_POSITION_ABSOLUTE = 'absolute';\n\n  var CSS_MEASURE_MODE_UNDEFINED = 'undefined';\n  var CSS_MEASURE_MODE_EXACTLY = 'exactly';\n  var CSS_MEASURE_MODE_AT_MOST = 'at-most';\n\n  var leading = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var trailing = {\n    'row': 'right',\n    'row-reverse': 'left',\n    'column': 'bottom',\n    'column-reverse': 'top'\n  };\n  var pos = {\n    'row': 'left',\n    'row-reverse': 'right',\n    'column': 'top',\n    'column-reverse': 'bottom'\n  };\n  var dim = {\n    'row': 'width',\n    'row-reverse': 'width',\n    'column': 'height',\n    'column-reverse': 'height'\n  };\n\n  // When transpiled to Java / C the node type has layout, children and style\n  // properties. For the JavaScript version this function adds these properties\n  // if they don't already exist.\n  function fillNodes(node) {\n    if (!node.layout || node.isDirty) {\n      node.layout = {\n        width: undefined,\n        height: undefined,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0\n      };\n    }\n\n    if (!node.style) {\n      node.style = {};\n    }\n\n    if (!node.children) {\n      node.children = [];\n    }\n\n    if (node.style.measure && node.children && node.children.length) {\n      throw new Error('Using custom measure function is supported only for leaf nodes.');\n    }\n\n    node.children.forEach(fillNodes);\n    return node;\n  }\n\n  function isUndefined(value) {\n    return value === undefined || isNaN(value);\n  }\n\n  function isRowDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_ROW ||\n           flexDirection === CSS_FLEX_DIRECTION_ROW_REVERSE;\n  }\n\n  function isColumnDirection(flexDirection) {\n    return flexDirection === CSS_FLEX_DIRECTION_COLUMN ||\n           flexDirection === CSS_FLEX_DIRECTION_COLUMN_REVERSE;\n  }\n\n  function getLeadingMargin(node, axis) {\n    if (node.style.marginStart !== undefined && isRowDirection(axis)) {\n      return node.style.marginStart;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.marginLeft;   break;\n      case 'row-reverse':    value = node.style.marginRight;  break;\n      case 'column':         value = node.style.marginTop;    break;\n      case 'column-reverse': value = node.style.marginBottom; break;\n    }\n\n    if (value !== undefined) {\n      return value;\n    }\n\n    if (node.style.margin !== undefined) {\n      return node.style.margin;\n    }\n\n    return 0;\n  }\n\n  function getTrailingMargin(node, axis) {\n    if (node.style.marginEnd !== undefined && isRowDirection(axis)) {\n      return node.style.marginEnd;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.marginRight;  break;\n      case 'row-reverse':    value = node.style.marginLeft;   break;\n      case 'column':         value = node.style.marginBottom; break;\n      case 'column-reverse': value = node.style.marginTop;    break;\n    }\n\n    if (value != null) {\n      return value;\n    }\n\n    if (node.style.margin !== undefined) {\n      return node.style.margin;\n    }\n\n    return 0;\n  }\n\n  function getLeadingPadding(node, axis) {\n    if (node.style.paddingStart !== undefined && node.style.paddingStart >= 0\n        && isRowDirection(axis)) {\n      return node.style.paddingStart;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.paddingLeft;   break;\n      case 'row-reverse':    value = node.style.paddingRight;  break;\n      case 'column':         value = node.style.paddingTop;    break;\n      case 'column-reverse': value = node.style.paddingBottom; break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\n      return node.style.padding;\n    }\n\n    return 0;\n  }\n\n  function getTrailingPadding(node, axis) {\n    if (node.style.paddingEnd !== undefined && node.style.paddingEnd >= 0\n        && isRowDirection(axis)) {\n      return node.style.paddingEnd;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.paddingRight;  break;\n      case 'row-reverse':    value = node.style.paddingLeft;   break;\n      case 'column':         value = node.style.paddingBottom; break;\n      case 'column-reverse': value = node.style.paddingTop;    break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.padding !== undefined && node.style.padding >= 0) {\n      return node.style.padding;\n    }\n\n    return 0;\n  }\n\n  function getLeadingBorder(node, axis) {\n    if (node.style.borderStartWidth !== undefined && node.style.borderStartWidth >= 0\n        && isRowDirection(axis)) {\n      return node.style.borderStartWidth;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.borderLeftWidth;   break;\n      case 'row-reverse':    value = node.style.borderRightWidth;  break;\n      case 'column':         value = node.style.borderTopWidth;    break;\n      case 'column-reverse': value = node.style.borderBottomWidth; break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n      return node.style.borderWidth;\n    }\n\n    return 0;\n  }\n\n  function getTrailingBorder(node, axis) {\n    if (node.style.borderEndWidth !== undefined && node.style.borderEndWidth >= 0\n        && isRowDirection(axis)) {\n      return node.style.borderEndWidth;\n    }\n\n    var value = null;\n    switch (axis) {\n      case 'row':            value = node.style.borderRightWidth;  break;\n      case 'row-reverse':    value = node.style.borderLeftWidth;   break;\n      case 'column':         value = node.style.borderBottomWidth; break;\n      case 'column-reverse': value = node.style.borderTopWidth;    break;\n    }\n\n    if (value != null && value >= 0) {\n      return value;\n    }\n\n    if (node.style.borderWidth !== undefined && node.style.borderWidth >= 0) {\n      return node.style.borderWidth;\n    }\n\n    return 0;\n  }\n\n  function getLeadingPaddingAndBorder(node, axis) {\n    return getLeadingPadding(node, axis) + getLeadingBorder(node, axis);\n  }\n\n  function getTrailingPaddingAndBorder(node, axis) {\n    return getTrailingPadding(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getBorderAxis(node, axis) {\n    return getLeadingBorder(node, axis) + getTrailingBorder(node, axis);\n  }\n\n  function getMarginAxis(node, axis) {\n    return getLeadingMargin(node, axis) + getTrailingMargin(node, axis);\n  }\n\n  function getPaddingAndBorderAxis(node, axis) {\n    return getLeadingPaddingAndBorder(node, axis) +\n        getTrailingPaddingAndBorder(node, axis);\n  }\n\n  function getJustifyContent(node) {\n    if (node.style.justifyContent) {\n      return node.style.justifyContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignContent(node) {\n    if (node.style.alignContent) {\n      return node.style.alignContent;\n    }\n    return 'flex-start';\n  }\n\n  function getAlignItem(node, child) {\n    if (child.style.alignSelf) {\n      return child.style.alignSelf;\n    }\n    if (node.style.alignItems) {\n      return node.style.alignItems;\n    }\n    return 'stretch';\n  }\n\n  function resolveAxis(axis, direction) {\n    if (direction === CSS_DIRECTION_RTL) {\n      if (axis === CSS_FLEX_DIRECTION_ROW) {\n        return CSS_FLEX_DIRECTION_ROW_REVERSE;\n      } else if (axis === CSS_FLEX_DIRECTION_ROW_REVERSE) {\n        return CSS_FLEX_DIRECTION_ROW;\n      }\n    }\n\n    return axis;\n  }\n\n  function resolveDirection(node, parentDirection) {\n    var direction;\n    if (node.style.direction) {\n      direction = node.style.direction;\n    } else {\n      direction = CSS_DIRECTION_INHERIT;\n    }\n\n    if (direction === CSS_DIRECTION_INHERIT) {\n      direction = (parentDirection === undefined ? CSS_DIRECTION_LTR : parentDirection);\n    }\n\n    return direction;\n  }\n\n  function getFlexDirection(node) {\n    if (node.style.flexDirection) {\n      return node.style.flexDirection;\n    }\n    return CSS_FLEX_DIRECTION_COLUMN;\n  }\n\n  function getCrossFlexDirection(flexDirection, direction) {\n    if (isColumnDirection(flexDirection)) {\n      return resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n    } else {\n      return CSS_FLEX_DIRECTION_COLUMN;\n    }\n  }\n\n  function getPositionType(node) {\n    if (node.style.position) {\n      return node.style.position;\n    }\n    return 'relative';\n  }\n\n  function isFlex(node) {\n    return (\n      getPositionType(node) === CSS_POSITION_RELATIVE &&\n      node.style.flex > 0\n    );\n  }\n\n  function isFlexWrap(node) {\n    return node.style.flexWrap === 'wrap';\n  }\n\n  function getDimWithMargin(node, axis) {\n    return node.layout[dim[axis]] + getMarginAxis(node, axis);\n  }\n\n  function isStyleDimDefined(node, axis) {\n    return node.style[dim[axis]] !== undefined && node.style[dim[axis]] >= 0;\n  }\n\n  function isLayoutDimDefined(node, axis) {\n    return node.layout[dim[axis]] !== undefined && node.layout[dim[axis]] >= 0;\n  }\n\n  function isPosDefined(node, pos) {\n    return node.style[pos] !== undefined;\n  }\n\n  function isMeasureDefined(node) {\n    return node.style.measure !== undefined;\n  }\n\n  function getPosition(node, pos) {\n    if (node.style[pos] !== undefined) {\n      return node.style[pos];\n    }\n    return 0;\n  }\n\n  function boundAxis(node, axis, value) {\n    var min = {\n      'row': node.style.minWidth,\n      'row-reverse': node.style.minWidth,\n      'column': node.style.minHeight,\n      'column-reverse': node.style.minHeight\n    }[axis];\n\n    var max = {\n      'row': node.style.maxWidth,\n      'row-reverse': node.style.maxWidth,\n      'column': node.style.maxHeight,\n      'column-reverse': node.style.maxHeight\n    }[axis];\n\n    var boundValue = value;\n    if (max !== undefined && max >= 0 && boundValue > max) {\n      boundValue = max;\n    }\n    if (min !== undefined && min >= 0 && boundValue < min) {\n      boundValue = min;\n    }\n    return boundValue;\n  }\n\n  function fmaxf(a, b) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  // When the user specifically sets a value for width or height\n  function setDimensionFromStyle(node, axis) {\n    // The parent already computed us a width or height. We just skip it\n    if (isLayoutDimDefined(node, axis)) {\n      return;\n    }\n    // We only run if there's a width or height defined\n    if (!isStyleDimDefined(node, axis)) {\n      return;\n    }\n\n    // The dimensions can never be smaller than the padding and border\n    node.layout[dim[axis]] = fmaxf(\n      boundAxis(node, axis, node.style[dim[axis]]),\n      getPaddingAndBorderAxis(node, axis)\n    );\n  }\n\n  function setTrailingPosition(node, child, axis) {\n    child.layout[trailing[axis]] = node.layout[dim[axis]] -\n        child.layout[dim[axis]] - child.layout[pos[axis]];\n  }\n\n  // If both left and right are defined, then use left. Otherwise return\n  // +left or -right depending on which is defined.\n  function getRelativePosition(node, axis) {\n    if (node.style[leading[axis]] !== undefined) {\n      return getPosition(node, leading[axis]);\n    }\n    return -getPosition(node, trailing[axis]);\n  }\n\n  function layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, /*css_direction_t*/parentDirection) {\n    var/*css_direction_t*/ direction = resolveDirection(node, parentDirection);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ mainAxis = resolveAxis(getFlexDirection(node), direction);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ crossAxis = getCrossFlexDirection(mainAxis, direction);\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ resolvedRowAxis = resolveAxis(CSS_FLEX_DIRECTION_ROW, direction);\n\n    // Handle width and height style attributes\n    setDimensionFromStyle(node, mainAxis);\n    setDimensionFromStyle(node, crossAxis);\n\n    // Set the resolved resolution in the node's layout\n    node.layout.direction = direction;\n\n    // The position is set by the parent, but we need to complete it with a\n    // delta composed of the margin and left/top/right/bottom\n    node.layout[leading[mainAxis]] += getLeadingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[trailing[mainAxis]] += getTrailingMargin(node, mainAxis) +\n      getRelativePosition(node, mainAxis);\n    node.layout[leading[crossAxis]] += getLeadingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n    node.layout[trailing[crossAxis]] += getTrailingMargin(node, crossAxis) +\n      getRelativePosition(node, crossAxis);\n\n    // Inline immutable values from the target node to avoid excessive method\n    // invocations during the layout calculation.\n    var/*int*/ childCount = node.children.length;\n    var/*float*/ paddingAndBorderAxisResolvedRow = getPaddingAndBorderAxis(node, resolvedRowAxis);\n    var/*float*/ paddingAndBorderAxisColumn = getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n\n    if (isMeasureDefined(node)) {\n      var/*bool*/ isResolvedRowDimDefined = isLayoutDimDefined(node, resolvedRowAxis);\n\n      var/*float*/ width = CSS_UNDEFINED;\n      var/*css_measure_mode_t*/ widthMode = CSS_MEASURE_MODE_UNDEFINED;\n      if (isStyleDimDefined(node, resolvedRowAxis)) {\n        width = node.style.width;\n        widthMode = CSS_MEASURE_MODE_EXACTLY;\n      } else if (isResolvedRowDimDefined) {\n        width = node.layout[dim[resolvedRowAxis]];\n        widthMode = CSS_MEASURE_MODE_EXACTLY;\n      } else {\n        width = parentMaxWidth -\n          getMarginAxis(node, resolvedRowAxis);\n        widthMode = CSS_MEASURE_MODE_AT_MOST;\n      }\n      width -= paddingAndBorderAxisResolvedRow;\n      if (isUndefined(width)) {\n        widthMode = CSS_MEASURE_MODE_UNDEFINED;\n      }\n\n      var/*float*/ height = CSS_UNDEFINED;\n      var/*css_measure_mode_t*/ heightMode = CSS_MEASURE_MODE_UNDEFINED;\n      if (isStyleDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n        height = node.style.height;\n        heightMode = CSS_MEASURE_MODE_EXACTLY;\n      } else if (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n        height = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]];\n        heightMode = CSS_MEASURE_MODE_EXACTLY;\n      } else {\n        height = parentMaxHeight -\n          getMarginAxis(node, resolvedRowAxis);\n        heightMode = CSS_MEASURE_MODE_AT_MOST;\n      }\n      height -= getPaddingAndBorderAxis(node, CSS_FLEX_DIRECTION_COLUMN);\n      if (isUndefined(height)) {\n        heightMode = CSS_MEASURE_MODE_UNDEFINED;\n      }\n\n      // We only need to give a dimension for the text if we haven't got any\n      // for it computed yet. It can either be from the style attribute or because\n      // the element is flexible.\n      var/*bool*/ isRowUndefined = !isStyleDimDefined(node, resolvedRowAxis) && !isResolvedRowDimDefined;\n      var/*bool*/ isColumnUndefined = !isStyleDimDefined(node, CSS_FLEX_DIRECTION_COLUMN) &&\n        isUndefined(node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]]);\n\n      // Let's not measure the text if we already know both dimensions\n      if (isRowUndefined || isColumnUndefined) {\n        var/*css_dim_t*/ measureDim = node.style.measure(\n          /*(c)!node->context,*/\n          /*(java)!layoutContext.measureOutput,*/\n          width,\n          widthMode,\n          height,\n          heightMode\n        );\n        if (isRowUndefined) {\n          node.layout.width = measureDim.width +\n            paddingAndBorderAxisResolvedRow;\n        }\n        if (isColumnUndefined) {\n          node.layout.height = measureDim.height +\n            paddingAndBorderAxisColumn;\n        }\n      }\n      if (childCount === 0) {\n        return;\n      }\n    }\n\n    var/*bool*/ isNodeFlexWrap = isFlexWrap(node);\n\n    var/*css_justify_t*/ justifyContent = getJustifyContent(node);\n\n    var/*float*/ leadingPaddingAndBorderMain = getLeadingPaddingAndBorder(node, mainAxis);\n    var/*float*/ leadingPaddingAndBorderCross = getLeadingPaddingAndBorder(node, crossAxis);\n    var/*float*/ paddingAndBorderAxisMain = getPaddingAndBorderAxis(node, mainAxis);\n    var/*float*/ paddingAndBorderAxisCross = getPaddingAndBorderAxis(node, crossAxis);\n\n    var/*bool*/ isMainDimDefined = isLayoutDimDefined(node, mainAxis);\n    var/*bool*/ isCrossDimDefined = isLayoutDimDefined(node, crossAxis);\n    var/*bool*/ isMainRowDirection = isRowDirection(mainAxis);\n\n    var/*int*/ i;\n    var/*int*/ ii;\n    var/*css_node_t**/ child;\n    var/*(c)!css_flex_direction_t*//*(java)!int*/ axis;\n\n    var/*css_node_t**/ firstAbsoluteChild = null;\n    var/*css_node_t**/ currentAbsoluteChild = null;\n\n    var/*float*/ definedMainDim = CSS_UNDEFINED;\n    if (isMainDimDefined) {\n      definedMainDim = node.layout[dim[mainAxis]] - paddingAndBorderAxisMain;\n    }\n\n    // We want to execute the next two loops one per line with flex-wrap\n    var/*int*/ startLine = 0;\n    var/*int*/ endLine = 0;\n    // var/*int*/ nextOffset = 0;\n    var/*int*/ alreadyComputedNextLayout = 0;\n    // We aggregate the total dimensions of the container in those two variables\n    var/*float*/ linesCrossDim = 0;\n    var/*float*/ linesMainDim = 0;\n    var/*int*/ linesCount = 0;\n    while (endLine < childCount) {\n      // <Loop A> Layout non flexible children and count children by type\n\n      // mainContentDim is accumulation of the dimensions and margin of all the\n      // non flexible children. This will be used in order to either set the\n      // dimensions of the node if none already exist, or to compute the\n      // remaining space left for the flexible children.\n      var/*float*/ mainContentDim = 0;\n\n      // There are three kind of children, non flexible, flexible and absolute.\n      // We need to know how many there are in order to distribute the space.\n      var/*int*/ flexibleChildrenCount = 0;\n      var/*float*/ totalFlexible = 0;\n      var/*int*/ nonFlexibleChildrenCount = 0;\n\n      // Use the line loop to position children in the main axis for as long\n      // as they are using a simple stacking behaviour. Children that are\n      // immediately stacked in the initial loop will not be touched again\n      // in <Loop C>.\n      var/*bool*/ isSimpleStackMain =\n          (isMainDimDefined && justifyContent === CSS_JUSTIFY_FLEX_START) ||\n          (!isMainDimDefined && justifyContent !== CSS_JUSTIFY_CENTER);\n      var/*int*/ firstComplexMain = (isSimpleStackMain ? childCount : startLine);\n\n      // Use the initial line loop to position children in the cross axis for\n      // as long as they are relatively positioned with alignment STRETCH or\n      // FLEX_START. Children that are immediately stacked in the initial loop\n      // will not be touched again in <Loop D>.\n      var/*bool*/ isSimpleStackCross = true;\n      var/*int*/ firstComplexCross = childCount;\n\n      var/*css_node_t**/ firstFlexChild = null;\n      var/*css_node_t**/ currentFlexChild = null;\n\n      var/*float*/ mainDim = leadingPaddingAndBorderMain;\n      var/*float*/ crossDim = 0;\n\n      var/*float*/ maxWidth = CSS_UNDEFINED;\n      var/*float*/ maxHeight = CSS_UNDEFINED;\n      for (i = startLine; i < childCount; ++i) {\n        child = node.children[i];\n        child.lineIndex = linesCount;\n\n        child.nextAbsoluteChild = null;\n        child.nextFlexChild = null;\n\n        var/*css_align_t*/ alignItem = getAlignItem(node, child);\n\n        // Pre-fill cross axis dimensions when the child is using stretch before\n        // we call the recursive layout pass\n        if (alignItem === CSS_ALIGN_STRETCH &&\n            getPositionType(child) === CSS_POSITION_RELATIVE &&\n            isCrossDimDefined &&\n            !isStyleDimDefined(child, crossAxis)) {\n          child.layout[dim[crossAxis]] = fmaxf(\n            boundAxis(child, crossAxis, node.layout[dim[crossAxis]] -\n              paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n            // You never want to go smaller than padding\n            getPaddingAndBorderAxis(child, crossAxis)\n          );\n        } else if (getPositionType(child) === CSS_POSITION_ABSOLUTE) {\n          // Store a private linked list of absolutely positioned children\n          // so that we can efficiently traverse them later.\n          if (firstAbsoluteChild === null) {\n            firstAbsoluteChild = child;\n          }\n          if (currentAbsoluteChild !== null) {\n            currentAbsoluteChild.nextAbsoluteChild = child;\n          }\n          currentAbsoluteChild = child;\n\n          // Pre-fill dimensions when using absolute position and both offsets for the axis are defined (either both\n          // left and right or top and bottom).\n          for (ii = 0; ii < 2; ii++) {\n            axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n            if (isLayoutDimDefined(node, axis) &&\n                !isStyleDimDefined(child, axis) &&\n                isPosDefined(child, leading[axis]) &&\n                isPosDefined(child, trailing[axis])) {\n              child.layout[dim[axis]] = fmaxf(\n                boundAxis(child, axis, node.layout[dim[axis]] -\n                  getPaddingAndBorderAxis(node, axis) -\n                  getMarginAxis(child, axis) -\n                  getPosition(child, leading[axis]) -\n                  getPosition(child, trailing[axis])),\n                // You never want to go smaller than padding\n                getPaddingAndBorderAxis(child, axis)\n              );\n            }\n          }\n        }\n\n        var/*float*/ nextContentDim = 0;\n\n        // It only makes sense to consider a child flexible if we have a computed\n        // dimension for the node.\n        if (isMainDimDefined && isFlex(child)) {\n          flexibleChildrenCount++;\n          totalFlexible += child.style.flex;\n\n          // Store a private linked list of flexible children so that we can\n          // efficiently traverse them later.\n          if (firstFlexChild === null) {\n            firstFlexChild = child;\n          }\n          if (currentFlexChild !== null) {\n            currentFlexChild.nextFlexChild = child;\n          }\n          currentFlexChild = child;\n\n          // Even if we don't know its exact size yet, we already know the padding,\n          // border and margin. We'll use this partial information, which represents\n          // the smallest possible size for the child, to compute the remaining\n          // available space.\n          nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +\n            getMarginAxis(child, mainAxis);\n\n        } else {\n          maxWidth = CSS_UNDEFINED;\n          maxHeight = CSS_UNDEFINED;\n\n          if (!isMainRowDirection) {\n            if (isLayoutDimDefined(node, resolvedRowAxis)) {\n              maxWidth = node.layout[dim[resolvedRowAxis]] -\n                paddingAndBorderAxisResolvedRow;\n            } else {\n              maxWidth = parentMaxWidth -\n                getMarginAxis(node, resolvedRowAxis) -\n                paddingAndBorderAxisResolvedRow;\n            }\n          } else {\n            if (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n              maxHeight = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n                  paddingAndBorderAxisColumn;\n            } else {\n              maxHeight = parentMaxHeight -\n                getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -\n                paddingAndBorderAxisColumn;\n            }\n          }\n\n          // This is the main recursive call. We layout non flexible children.\n          if (alreadyComputedNextLayout === 0) {\n            layoutNode(/*(java)!layoutContext, */child, maxWidth, maxHeight, direction);\n          }\n\n          // Absolute positioned elements do not take part of the layout, so we\n          // don't use them to compute mainContentDim\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            nonFlexibleChildrenCount++;\n            // At this point we know the final size and margin of the element.\n            nextContentDim = getDimWithMargin(child, mainAxis);\n          }\n        }\n\n        // The element we are about to add would make us go to the next line\n        if (isNodeFlexWrap &&\n            isMainDimDefined &&\n            mainContentDim + nextContentDim > definedMainDim &&\n            // If there's only one element, then it's bigger than the content\n            // and needs its own line\n            i !== startLine) {\n          nonFlexibleChildrenCount--;\n          alreadyComputedNextLayout = 1;\n          break;\n        }\n\n        // Disable simple stacking in the main axis for the current line as\n        // we found a non-trivial child. The remaining children will be laid out\n        // in <Loop C>.\n        if (isSimpleStackMain &&\n            (getPositionType(child) !== CSS_POSITION_RELATIVE || isFlex(child))) {\n          isSimpleStackMain = false;\n          firstComplexMain = i;\n        }\n\n        // Disable simple stacking in the cross axis for the current line as\n        // we found a non-trivial child. The remaining children will be laid out\n        // in <Loop D>.\n        if (isSimpleStackCross &&\n            (getPositionType(child) !== CSS_POSITION_RELATIVE ||\n                (alignItem !== CSS_ALIGN_STRETCH && alignItem !== CSS_ALIGN_FLEX_START) ||\n                (alignItem == CSS_ALIGN_STRETCH && !isCrossDimDefined))) {\n          isSimpleStackCross = false;\n          firstComplexCross = i;\n        }\n\n        if (isSimpleStackMain) {\n          child.layout[pos[mainAxis]] += mainDim;\n          if (isMainDimDefined) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n\n          mainDim += getDimWithMargin(child, mainAxis);\n          crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n        }\n\n        if (isSimpleStackCross) {\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;\n          if (isCrossDimDefined) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n\n        alreadyComputedNextLayout = 0;\n        mainContentDim += nextContentDim;\n        endLine = i + 1;\n      }\n\n      // <Loop B> Layout flexible children and allocate empty space\n\n      // In order to position the elements in the main axis, we have two\n      // controls. The space between the beginning and the first element\n      // and the space between each two elements.\n      var/*float*/ leadingMainDim = 0;\n      var/*float*/ betweenMainDim = 0;\n\n      // The remaining available space that needs to be allocated\n      var/*float*/ remainingMainDim = 0;\n      if (isMainDimDefined) {\n        remainingMainDim = definedMainDim - mainContentDim;\n      } else {\n        remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;\n      }\n\n      // If there are flexible children in the mix, they are going to fill the\n      // remaining space\n      if (flexibleChildrenCount !== 0) {\n        var/*float*/ flexibleMainDim = remainingMainDim / totalFlexible;\n        var/*float*/ baseMainDim;\n        var/*float*/ boundMainDim;\n\n        // If the flex share of remaining space doesn't meet min/max bounds,\n        // remove this child from flex calculations.\n        currentFlexChild = firstFlexChild;\n        while (currentFlexChild !== null) {\n          baseMainDim = flexibleMainDim * currentFlexChild.style.flex +\n              getPaddingAndBorderAxis(currentFlexChild, mainAxis);\n          boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);\n\n          if (baseMainDim !== boundMainDim) {\n            remainingMainDim -= boundMainDim;\n            totalFlexible -= currentFlexChild.style.flex;\n          }\n\n          currentFlexChild = currentFlexChild.nextFlexChild;\n        }\n        flexibleMainDim = remainingMainDim / totalFlexible;\n\n        // The non flexible children can overflow the container, in this case\n        // we should just assume that there is no space available.\n        if (flexibleMainDim < 0) {\n          flexibleMainDim = 0;\n        }\n\n        currentFlexChild = firstFlexChild;\n        while (currentFlexChild !== null) {\n          // At this point we know the final size of the element in the main\n          // dimension\n          currentFlexChild.layout[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,\n            flexibleMainDim * currentFlexChild.style.flex +\n                getPaddingAndBorderAxis(currentFlexChild, mainAxis)\n          );\n\n          maxWidth = CSS_UNDEFINED;\n          if (isLayoutDimDefined(node, resolvedRowAxis)) {\n            maxWidth = node.layout[dim[resolvedRowAxis]] -\n              paddingAndBorderAxisResolvedRow;\n          } else if (!isMainRowDirection) {\n            maxWidth = parentMaxWidth -\n              getMarginAxis(node, resolvedRowAxis) -\n              paddingAndBorderAxisResolvedRow;\n          }\n          maxHeight = CSS_UNDEFINED;\n          if (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) {\n            maxHeight = node.layout[dim[CSS_FLEX_DIRECTION_COLUMN]] -\n              paddingAndBorderAxisColumn;\n          } else if (isMainRowDirection) {\n            maxHeight = parentMaxHeight -\n              getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -\n              paddingAndBorderAxisColumn;\n          }\n\n          // And we recursively call the layout algorithm for this child\n          layoutNode(/*(java)!layoutContext, */currentFlexChild, maxWidth, maxHeight, direction);\n\n          child = currentFlexChild;\n          currentFlexChild = currentFlexChild.nextFlexChild;\n          child.nextFlexChild = null;\n        }\n\n      // We use justifyContent to figure out how to allocate the remaining\n      // space available\n      } else if (justifyContent !== CSS_JUSTIFY_FLEX_START) {\n        if (justifyContent === CSS_JUSTIFY_CENTER) {\n          leadingMainDim = remainingMainDim / 2;\n        } else if (justifyContent === CSS_JUSTIFY_FLEX_END) {\n          leadingMainDim = remainingMainDim;\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_BETWEEN) {\n          remainingMainDim = fmaxf(remainingMainDim, 0);\n          if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 !== 0) {\n            betweenMainDim = remainingMainDim /\n              (flexibleChildrenCount + nonFlexibleChildrenCount - 1);\n          } else {\n            betweenMainDim = 0;\n          }\n        } else if (justifyContent === CSS_JUSTIFY_SPACE_AROUND) {\n          // Space on the edges is half of the space between elements\n          betweenMainDim = remainingMainDim /\n            (flexibleChildrenCount + nonFlexibleChildrenCount);\n          leadingMainDim = betweenMainDim / 2;\n        }\n      }\n\n      // <Loop C> Position elements in the main axis and compute dimensions\n\n      // At this point, all the children have their dimensions set. We need to\n      // find their position. In order to do that, we accumulate data in\n      // variables that are also useful to compute the total dimensions of the\n      // container!\n      mainDim += leadingMainDim;\n\n      for (i = firstComplexMain; i < endLine; ++i) {\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[mainAxis])) {\n          // In case the child is position absolute and has left/top being\n          // defined, we override the position to whatever the user said\n          // (and margin/border).\n          child.layout[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +\n            getLeadingBorder(node, mainAxis) +\n            getLeadingMargin(child, mainAxis);\n        } else {\n          // If the child is position absolute (without top/left) or relative,\n          // we put it at the current accumulated offset.\n          child.layout[pos[mainAxis]] += mainDim;\n\n          // Define the trailing position accordingly.\n          if (isMainDimDefined) {\n            setTrailingPosition(node, child, mainAxis);\n          }\n\n          // Now that we placed the element, we need to update the variables\n          // We only need to do that for relative elements. Absolute elements\n          // do not take part in that phase.\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            // The main dimension is the sum of all the elements dimension plus\n            // the spacing.\n            mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);\n            // The cross dimension is the max of the elements dimension since there\n            // can only be one element in that cross dimension.\n            crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));\n          }\n        }\n      }\n\n      var/*float*/ containerCrossAxis = node.layout[dim[crossAxis]];\n      if (!isCrossDimDefined) {\n        containerCrossAxis = fmaxf(\n          // For the cross dim, we add both sides at the end because the value\n          // is aggregate via a max function. Intermediate negative values\n          // can mess this computation otherwise\n          boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),\n          paddingAndBorderAxisCross\n        );\n      }\n\n      // <Loop D> Position elements in the cross axis\n      for (i = firstComplexCross; i < endLine; ++i) {\n        child = node.children[i];\n\n        if (getPositionType(child) === CSS_POSITION_ABSOLUTE &&\n            isPosDefined(child, leading[crossAxis])) {\n          // In case the child is absolutely positionned and has a\n          // top/left/bottom/right being set, we override all the previously\n          // computed positions to set it correctly.\n          child.layout[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +\n            getLeadingBorder(node, crossAxis) +\n            getLeadingMargin(child, crossAxis);\n\n        } else {\n          var/*float*/ leadingCrossDim = leadingPaddingAndBorderCross;\n\n          // For a relative children, we're either using alignItems (parent) or\n          // alignSelf (child) in order to determine the position in the cross axis\n          if (getPositionType(child) === CSS_POSITION_RELATIVE) {\n            /*eslint-disable */\n            // This variable is intentionally re-defined as the code is transpiled to a block scope language\n            var/*css_align_t*/ alignItem = getAlignItem(node, child);\n            /*eslint-enable */\n            if (alignItem === CSS_ALIGN_STRETCH) {\n              // You can only stretch if the dimension has not already been defined\n              // previously.\n              if (!isStyleDimDefined(child, crossAxis)) {\n                var/*float*/ dimCrossAxis = child.layout[dim[crossAxis]];\n                child.layout[dim[crossAxis]] = fmaxf(\n                  boundAxis(child, crossAxis, containerCrossAxis -\n                    paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),\n                  // You never want to go smaller than padding\n                  getPaddingAndBorderAxis(child, crossAxis)\n                );\n\n                // If the size has changed, and this child has children we need to re-layout this child\n                if (dimCrossAxis != child.layout[dim[crossAxis]] && child.children.length > 0) {\n                  // Reset child margins before re-layout as they are added back in layoutNode and would be doubled\n                  child.layout[leading[mainAxis]] -= getLeadingMargin(child, mainAxis) +\n                    getRelativePosition(child, mainAxis);\n                  child.layout[trailing[mainAxis]] -= getTrailingMargin(child, mainAxis) +\n                    getRelativePosition(child, mainAxis);\n                  child.layout[leading[crossAxis]] -= getLeadingMargin(child, crossAxis) +\n                    getRelativePosition(child, crossAxis);\n                  child.layout[trailing[crossAxis]] -= getTrailingMargin(child, crossAxis) +\n                    getRelativePosition(child, crossAxis);\n\n                  layoutNode(/*(java)!layoutContext, */child, maxWidth, maxHeight, direction);\n                }\n              }\n            } else if (alignItem !== CSS_ALIGN_FLEX_START) {\n              // The remaining space between the parent dimensions+padding and child\n              // dimensions+margin.\n              var/*float*/ remainingCrossDim = containerCrossAxis -\n                paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);\n\n              if (alignItem === CSS_ALIGN_CENTER) {\n                leadingCrossDim += remainingCrossDim / 2;\n              } else { // CSS_ALIGN_FLEX_END\n                leadingCrossDim += remainingCrossDim;\n              }\n            }\n          }\n\n          // And we apply the position\n          child.layout[pos[crossAxis]] += linesCrossDim + leadingCrossDim;\n\n          // Define the trailing position accordingly.\n          if (isCrossDimDefined) {\n            setTrailingPosition(node, child, crossAxis);\n          }\n        }\n      }\n\n      linesCrossDim += crossDim;\n      linesMainDim = fmaxf(linesMainDim, mainDim);\n      linesCount += 1;\n      startLine = endLine;\n    }\n\n    // <Loop E>\n    //\n    // Note(prenaux): More than one line, we need to layout the crossAxis\n    // according to alignContent.\n    //\n    // Note that we could probably remove <Loop D> and handle the one line case\n    // here too, but for the moment this is safer since it won't interfere with\n    // previously working code.\n    //\n    // See specs:\n    // http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm\n    // section 9.4\n    //\n    if (linesCount > 1 && isCrossDimDefined) {\n      var/*float*/ nodeCrossAxisInnerSize = node.layout[dim[crossAxis]] -\n          paddingAndBorderAxisCross;\n      var/*float*/ remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;\n\n      var/*float*/ crossDimLead = 0;\n      var/*float*/ currentLead = leadingPaddingAndBorderCross;\n\n      var/*css_align_t*/ alignContent = getAlignContent(node);\n      if (alignContent === CSS_ALIGN_FLEX_END) {\n        currentLead += remainingAlignContentDim;\n      } else if (alignContent === CSS_ALIGN_CENTER) {\n        currentLead += remainingAlignContentDim / 2;\n      } else if (alignContent === CSS_ALIGN_STRETCH) {\n        if (nodeCrossAxisInnerSize > linesCrossDim) {\n          crossDimLead = (remainingAlignContentDim / linesCount);\n        }\n      }\n\n      var/*int*/ endIndex = 0;\n      for (i = 0; i < linesCount; ++i) {\n        var/*int*/ startIndex = endIndex;\n\n        // compute the line's height and find the endIndex\n        var/*float*/ lineHeight = 0;\n        for (ii = startIndex; ii < childCount; ++ii) {\n          child = node.children[ii];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n          if (child.lineIndex !== i) {\n            break;\n          }\n          if (isLayoutDimDefined(child, crossAxis)) {\n            lineHeight = fmaxf(\n              lineHeight,\n              child.layout[dim[crossAxis]] + getMarginAxis(child, crossAxis)\n            );\n          }\n        }\n        endIndex = ii;\n        lineHeight += crossDimLead;\n\n        for (ii = startIndex; ii < endIndex; ++ii) {\n          child = node.children[ii];\n          if (getPositionType(child) !== CSS_POSITION_RELATIVE) {\n            continue;\n          }\n\n          var/*css_align_t*/ alignContentAlignItem = getAlignItem(node, child);\n          if (alignContentAlignItem === CSS_ALIGN_FLEX_START) {\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n          } else if (alignContentAlignItem === CSS_ALIGN_FLEX_END) {\n            child.layout[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child.layout[dim[crossAxis]];\n          } else if (alignContentAlignItem === CSS_ALIGN_CENTER) {\n            var/*float*/ childHeight = child.layout[dim[crossAxis]];\n            child.layout[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2;\n          } else if (alignContentAlignItem === CSS_ALIGN_STRETCH) {\n            child.layout[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);\n            // TODO(prenaux): Correctly set the height of items with undefined\n            //                (auto) crossAxis dimension.\n          }\n        }\n\n        currentLead += lineHeight;\n      }\n    }\n\n    var/*bool*/ needsMainTrailingPos = false;\n    var/*bool*/ needsCrossTrailingPos = false;\n\n    // If the user didn't specify a width or height, and it has not been set\n    // by the container, then we set it via the children.\n    if (!isMainDimDefined) {\n      node.layout[dim[mainAxis]] = fmaxf(\n        // We're missing the last padding at this point to get the final\n        // dimension\n        boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),\n        // We can never assign a width smaller than the padding and borders\n        paddingAndBorderAxisMain\n      );\n\n      if (mainAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n          mainAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n        needsMainTrailingPos = true;\n      }\n    }\n\n    if (!isCrossDimDefined) {\n      node.layout[dim[crossAxis]] = fmaxf(\n        // For the cross dim, we add both sides at the end because the value\n        // is aggregate via a max function. Intermediate negative values\n        // can mess this computation otherwise\n        boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),\n        paddingAndBorderAxisCross\n      );\n\n      if (crossAxis === CSS_FLEX_DIRECTION_ROW_REVERSE ||\n          crossAxis === CSS_FLEX_DIRECTION_COLUMN_REVERSE) {\n        needsCrossTrailingPos = true;\n      }\n    }\n\n    // <Loop F> Set trailing position if necessary\n    if (needsMainTrailingPos || needsCrossTrailingPos) {\n      for (i = 0; i < childCount; ++i) {\n        child = node.children[i];\n\n        if (needsMainTrailingPos) {\n          setTrailingPosition(node, child, mainAxis);\n        }\n\n        if (needsCrossTrailingPos) {\n          setTrailingPosition(node, child, crossAxis);\n        }\n      }\n    }\n\n    // <Loop G> Calculate dimensions for absolutely positioned elements\n    currentAbsoluteChild = firstAbsoluteChild;\n    while (currentAbsoluteChild !== null) {\n      // Pre-fill dimensions when using absolute position and both offsets for\n      // the axis are defined (either both left and right or top and bottom).\n      for (ii = 0; ii < 2; ii++) {\n        axis = (ii !== 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;\n\n        if (isLayoutDimDefined(node, axis) &&\n            !isStyleDimDefined(currentAbsoluteChild, axis) &&\n            isPosDefined(currentAbsoluteChild, leading[axis]) &&\n            isPosDefined(currentAbsoluteChild, trailing[axis])) {\n          currentAbsoluteChild.layout[dim[axis]] = fmaxf(\n            boundAxis(currentAbsoluteChild, axis, node.layout[dim[axis]] -\n              getBorderAxis(node, axis) -\n              getMarginAxis(currentAbsoluteChild, axis) -\n              getPosition(currentAbsoluteChild, leading[axis]) -\n              getPosition(currentAbsoluteChild, trailing[axis])\n            ),\n            // You never want to go smaller than padding\n            getPaddingAndBorderAxis(currentAbsoluteChild, axis)\n          );\n        }\n\n        if (isPosDefined(currentAbsoluteChild, trailing[axis]) &&\n            !isPosDefined(currentAbsoluteChild, leading[axis])) {\n          currentAbsoluteChild.layout[leading[axis]] =\n            node.layout[dim[axis]] -\n            currentAbsoluteChild.layout[dim[axis]] -\n            getPosition(currentAbsoluteChild, trailing[axis]);\n        }\n      }\n\n      child = currentAbsoluteChild;\n      currentAbsoluteChild = currentAbsoluteChild.nextAbsoluteChild;\n      child.nextAbsoluteChild = null;\n    }\n  }\n\n  function layoutNode(node, parentMaxWidth, parentMaxHeight, parentDirection) {\n    node.shouldUpdate = true;\n\n    var direction = node.style.direction || CSS_DIRECTION_LTR;\n    var skipLayout =\n      !node.isDirty &&\n      node.lastLayout &&\n      node.lastLayout.requestedHeight === node.layout.height &&\n      node.lastLayout.requestedWidth === node.layout.width &&\n      node.lastLayout.parentMaxWidth === parentMaxWidth &&\n      node.lastLayout.parentMaxHeight === parentMaxHeight &&\n      node.lastLayout.direction === direction;\n\n    if (skipLayout) {\n      node.layout.width = node.lastLayout.width;\n      node.layout.height = node.lastLayout.height;\n      node.layout.top = node.lastLayout.top;\n      node.layout.left = node.lastLayout.left;\n    } else {\n      if (!node.lastLayout) {\n        node.lastLayout = {};\n      }\n\n      node.lastLayout.requestedWidth = node.layout.width;\n      node.lastLayout.requestedHeight = node.layout.height;\n      node.lastLayout.parentMaxWidth = parentMaxWidth;\n      node.lastLayout.parentMaxHeight = parentMaxHeight;\n      node.lastLayout.direction = direction;\n\n      // Reset child layouts\n      node.children.forEach(function(child) {\n        child.layout.width = undefined;\n        child.layout.height = undefined;\n        child.layout.top = 0;\n        child.layout.left = 0;\n      });\n\n      layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, parentDirection);\n\n      node.lastLayout.width = node.layout.width;\n      node.lastLayout.height = node.layout.height;\n      node.lastLayout.top = node.layout.top;\n      node.lastLayout.left = node.layout.left;\n    }\n  }\n\n  return {\n    layoutNodeImpl: layoutNodeImpl,\n    computeLayout: layoutNode,\n    fillNodes: fillNodes\n  };\n})();\n\n// This module export is only used for the purposes of unit testing this file. When\n// the library is packaged this file is included within css-layout.js which forms\n// the public API.\nif (typeof exports === 'object') {\n  module.exports = computeLayout;\n}\n\n\n  return function(node) {\n    /*eslint-disable */\n    // disabling ESLint because this code relies on the above include\n    computeLayout.fillNodes(node);\n    computeLayout.computeLayout(node);\n    /*eslint-enable */\n  };\n}));\n"]}